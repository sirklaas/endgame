<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Endgame Display | Ranking Presentation</title>
    <meta name="description" content="Display view for Endgame presentation system - for beamer/large screen">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="styles.css">
</head>

<body class="display-mode">
    <div class="container">
        <header class="header">
            <h1>Endgame</h1>
            <p class="subtitle">Choose Your Path</p>
        </header>

        <div id="cardsGrid" class="cards-grid">
            <!-- Cards will be dynamically inserted here -->
        </div>
    </div>

    <!-- Video Container -->
    <div id="videoContainer" class="video-container">
        <div class="video-wrapper">
            <h2 id="videoTitle" class="video-title"></h2>
            <video id="videoPlayer" class="video-player" playsinline></video>
        </div>
    </div>

    <script src="app.js"></script>
    <script>
        // Display-specific logic (synchronized with presenter)
        const state = new EndgameState();
        const cardsGrid = document.getElementById('cardsGrid');
        const videoContainer = document.getElementById('videoContainer');
        const videoPlayer = document.getElementById('videoPlayer');
        const videoTitle = document.getElementById('videoTitle');
        const videoController = new VideoController(videoPlayer, videoTitle);

        let currentState = null;

        // Render cards
        function renderCards() {
            cardsGrid.innerHTML = cards.map(card => `
        <div class="card ${state.isCardUsed(card.id) ? 'used' : ''}" data-card-id="${card.id}">
          <div class="card-content">
            <img src="${card.image}" alt="${card.name}" class="card-image">
            <div class="card-label">${card.name}</div>
          </div>
        </div>
      `).join('');
        }

        // Update UI based on state
        function updateUI() {
            renderCards();

            // Update selected card highlighting
            document.querySelectorAll('.card').forEach(cardElement => {
                const cardId = cardElement.dataset.cardId;
                updateCardVisuals(cardElement, cardId, state);
            });

            // Handle video display
            if (state.playbackState === 'grid') {
                videoContainer.classList.remove('active');
                videoController.reset();
            } else if (state.playbackState === 'paused') {
                const card = getCardById(state.selectedCard);
                if (card) {
                    videoContainer.classList.add('active');
                    videoController.loadCard(card);
                }
            } else if (state.playbackState === 'playing') {
                videoController.play();
            }
        }

        // Listen for storage changes (from presenter)
        window.addEventListener('storage', (e) => {
            if (e.key === 'endgameState') {
                // Reload state and update UI
                state.loadState();
                updateUI();
                console.log('Display synced with presenter:', state);
            }
        });

        // Also poll state periodically (backup for same-window testing)
        let lastTimestamp = 0;
        setInterval(() => {
            try {
                const saved = localStorage.getItem('endgameState');
                if (saved) {
                    const newState = JSON.parse(saved);
                    if (newState.timestamp !== lastTimestamp) {
                        lastTimestamp = newState.timestamp;
                        state.loadState();
                        updateUI();
                    }
                }
            } catch (e) {
                console.error('Error checking state:', e);
            }
        }, 100);

        // Video ended - auto return to grid
        videoPlayer.addEventListener('ended', () => {
            if (state.playbackState === 'playing') {
                // This will be triggered by presenter, but handle it anyway
                videoContainer.classList.remove('active');
                videoController.reset();
            }
        });

        // Initial render
        updateUI();

        // Log for debugging
        console.log('Display initialized. Listening for presenter updates...');
        console.log('Current state:', state);
    </script>
</body>

</html>